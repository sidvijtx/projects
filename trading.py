# -*- coding: utf-8 -*-
"""trading.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tyKKrRiA39-JNAdVYIADw_PKUTHNoB7Q
"""







import numpy as np
import yfinance as yf
import pandas as pd
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Download stock price data
data = yf.download('F', start='2010-07-20', end='2011-08-01')

# Extract 'Close' price and compute percentage change
prices = data['Close']
percentage_changes = prices.pct_change().dropna() * 100

# Prepare data for polynomial regression
def create_features(prices, window_size):
    X, y = [], []
    for i in range(window_size, len(prices)):
        X.append(prices[i - window_size:i])
        y.append(prices[i])
    return np.array(X), np.array(y)

window_size = 10
X, y = create_features(percentage_changes.values, window_size)

# Polynomial features
poly = PolynomialFeatures(degree=3)  # Change degree as needed
X_poly = poly.fit_transform(X)

# Split data into training and test sets
split = int(0.8 * len(X))
X_train, X_test = X_poly[:split], X_poly[split:]
y_train, y_test = y[:split], y[split:]

# Fit polynomial regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate model
mse = mean_squared_error(y_test, y_pred)
print(f'Polynomial Regression Mean Squared Error: {mse}')

# Plot actual vs. predicted returns
plt.figure(figsize=(14, 6))
plt.plot(range(len(y_test)), y_test, label='Actual Returns', color='blue', alpha=0.7)
plt.plot(range(len(y_pred)), y_pred, label='Predicted Returns', color='red', alpha=0.7)
plt.xlabel('Index')
plt.ylabel('Percentage Change (%)')
plt.title('Polynomial Regression: Actual vs. Predicted Returns')
plt.legend()
plt.grid(True)
plt.show()



import yfinance as yf
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Download stock data
data = yf.download('F', start='2010-07-20', end='2011-08-01')
data = data[['Close']]
data['Returns'] = data['Close'].pct_change().dropna() * 100  # Calculate percentage change for returns

# Drop NA values (first return will be NaN after pct_change)
data = data.dropna()

# Prepare features (X) and target (y)
X = data['Returns'].values[:-1].reshape(-1, 1)  # Use all but the last return for features
y = data['Returns'].values[1:]  # Use all but the first return for targets

# Use the index for the dates
dates = data.index[1:]  # Shifted index to align with y

# Split the data
X_train, X_test, y_train, y_test, dates_train, dates_test = train_test_split(X, y, dates, test_size=0.2, random_state=42)

# Train the Random Forest model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Make predictions
predictions = model.predict(X_test)

# Create a DataFrame to hold actual vs. predicted returns with dates
results = pd.DataFrame({'Date': dates_test, 'Actual Returns': y_test, 'Predicted Returns': predictions})
results = results.sort_values(by='Date')  # Sort by date

# Plot actual vs predicted returns
plt.figure(figsize=(12, 6))
plt.plot(results['Date'], results['Actual Returns'], label='Actual Returns', color='blue', marker='o')
plt.plot(results['Date'], results['Predicted Returns'], label='Predicted Returns', color='red', linestyle='--', marker='x')
plt.title('Random Forest: Actual vs Predicted Stock Returns')
plt.xlabel('Date')
plt.ylabel('Returns (%)')
plt.legend()
plt.grid(True)
plt.show()

import yfinance as yf
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import joblib

# Step 1: Download and prepare initial stock data
data = yf.download('F', start='2010-07-20', end='2011-08-01')
data = data[['Close']]
data['Returns'] = data['Close'].pct_change().dropna() * 100
data = data.dropna()

X = data['Returns'].values[:-1].reshape(-1, 1)
y = data['Returns'].values[1:]
dates = data.index[1:]

X_train, X_test, y_train, y_test, dates_train, dates_test = train_test_split(X, y, dates, test_size=0.2, random_state=42)

# Step 2: Train and save the model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Save the model
joblib.dump(model, 'random_forest_model.pkl')

# Step 3: Load new stock data for the future period
future_data = yf.download('F', start='2011-08-01', end='2015-01-01')
future_data = future_data[['Close']]
future_data['Returns'] = future_data['Close'].pct_change().dropna() * 100
future_data = future_data.dropna()

X_future = future_data['Returns'].values[:-1].reshape(-1, 1)
dates_future = future_data.index[1:]

# Step 4: Load the saved model and make predictions
loaded_model = joblib.load('random_forest_model.pkl')
predictions_future = loaded_model.predict(X_future)

# Step 5: Create a DataFrame for the future period predictions and plot
future_results = pd.DataFrame({'Date': dates_future, 'Predicted Returns': predictions_future})
future_results = future_results.sort_values(by='Date')

plt.figure(figsize=(12, 6))
plt.plot(future_results['Date'], future_results['Predicted Returns'], label='Predicted Returns', color='red', linestyle='--', marker='x')
plt.title('Random Forest: Predicted Stock Returns (2011-2015)')
plt.xlabel('Date')
plt.ylabel('Returns (%)')
plt.legend()
plt.grid(True)
plt.show()

import yfinance as yf
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import joblib

# Step 1: Download and prepare initial stock data
data = yf.download('F', start='2010-07-20', end='2011-08-01')
data = data[['Close']]
data['Returns'] = data['Close'].pct_change().dropna() * 100
data = data.dropna()

X = data['Returns'].values[:-1].reshape(-1, 1)
y = data['Returns'].values[1:]
dates = data.index[1:]

X_train, X_test, y_train, y_test, dates_train, dates_test = train_test_split(X, y, dates, test_size=0.2, random_state=42)

# Step 2: Train and save the model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Save the model
joblib.dump(model, 'random_forest_model.pkl')

# Step 3: Load new stock data for the future period
future_data = yf.download('F', start='2011-08-01', end='2015-01-01')
future_data = future_data[['Close']]
future_data['Returns'] = future_data['Close'].pct_change().dropna() * 100
future_data = future_data.dropna()

X_future = future_data['Returns'].values[:-1].reshape(-1, 1)
y_future = future_data['Returns'].values[1:]
dates_future = future_data.index[1:]

# Step 4: Load the saved model and make predictions
loaded_model = joblib.load('random_forest_model.pkl')
predictions_future = loaded_model.predict(X_future)

# Create a DataFrame to hold actual and predicted returns with dates for the future period
future_results = pd.DataFrame({
    'Date': dates_future,
    'Actual Returns': y_future,
    'Predicted Returns': predictions_future
})
future_results = future_results.sort_values(by='Date')

# Step 5: Plotting
plt.figure(figsize=(14, 10))
years = future_results['Date'].dt.year.unique()  # Extract unique years

for i, year in enumerate(years):
    plt.subplot(len(years), 1, i + 1)
    yearly_data = future_results[future_results['Date'].dt.year == year]  # Filter data by year

    plt.plot(yearly_data['Date'], yearly_data['Actual Returns'], label='Actual Returns', color='blue', marker='o')
    plt.plot(yearly_data['Date'], yearly_data['Predicted Returns'], label='Predicted Returns', color='red', linestyle='--', marker='x')

    plt.title(f'Stock Returns for {year}')
    plt.xlabel('Date')
    plt.ylabel('Returns (%)')
    plt.legend()
    plt.grid(True)

plt.tight_layout()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Convert 'Date' columns to datetime if they are not already
future_results['Date'] = pd.to_datetime(future_results['Date'])
#future_data['Date'] = pd.to_datetime(future_data['Date']) #This line is causing the error. The future_data dataframe has no column 'Date'

# Set the date as the index for both dataframes
future_results.set_index('Date', inplace=True)
#future_data.set_index('Date', inplace=True) # Remove this line since future_data already has Date as index

# Parameters
initial_cash = 10000
cash = initial_cash
position = 0
buy_threshold = 0.1
sell_threshold = -0.1

# Create a DataFrame for simulation
simulation_results = pd.DataFrame(index=future_results.index)
simulation_results['Actual Returns'] = future_results['Actual Returns']
simulation_results['Predicted Returns'] = future_results['Predicted Returns']
simulation_results['Signal'] = 0  # 1 for buy, -1 for sell
simulation_results['Position'] = 0  # Shares held
simulation_results['Cash'] = cash
simulation_results['Portfolio Value'] = cash

# Initialize
cash = initial_cash
position = 0
buy_price = 0

# Simulation
for i in range(1, len(simulation_results)):
    # Check for Buy Signal
    if (simulation_results['Predicted Returns'].iloc[i] > buy_threshold and
        simulation_results['Predicted Returns'].iloc[i - 1] <= buy_threshold):
        if cash > 0:
            buy_price = future_data['Close'].iloc[i]
            position = cash / buy_price  # Buy as many shares as possible
            cash = 0
            simulation_results.at[simulation_results.index[i], 'Signal'] = 1
            simulation_results.at[simulation_results.index[i], 'Position'] = position
            simulation_results.at[simulation_results.index[i], 'Cash'] = cash
            print(f"Buy Signal: Bought shares at {buy_price} on {simulation_results.index[i]}")

    # Check for Sell Signal
    elif (simulation_results['Predicted Returns'].iloc[i] < sell_threshold and
          simulation_results['Predicted Returns'].iloc[i - 1] >= sell_threshold):
        if position > 0:
            sell_price = future_data['Close'].iloc[i]
            cash = position * sell_price  # Sell all shares
            position = 0
            simulation_results.at[simulation_results.index[i], 'Signal'] = -1
            simulation_results.at[simulation_results.index[i], 'Position'] = position
            simulation_results.at[simulation_results.index[i], 'Cash'] = cash
            print(f"Sell Signal: Sold shares at {sell_price} on {simulation_results.index[i]}")

    # Track Portfolio Value
    current_price = future_data['Close'].iloc[i]
    if position > 0:
        # If holding, adjust value by returns
        portfolio_value = cash + (position * current_price * (1 + simulation_results['Actual Returns'].iloc[i]))
    else:
        # If not holding, just add cash
        portfolio_value = cash

    simulation_results.at[simulation_results.index[i], 'Portfolio Value'] = portfolio_value

# Final Portfolio Value
final_value = simulation_results['Portfolio Value'].iloc[-1]
profit = final_value - initial_cash
print(f"Final Portfolio Value: ${final_value:.2f}")
print(f"Profit: ${profit:.2f}")

# Plotting
plt.figure(figsize=(14, 7))
plt.plot(simulation_results.index, simulation_results['Portfolio Value'], label='Portfolio Value', color='green')
plt.title('Trading Simulation Portfolio Value')
plt.xlabel('Date')